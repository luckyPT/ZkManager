package top.letsgogo.rpc.Iservice; /**
 * Autogenerated by Thrift
 * <p/>
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.FieldMetaData;
import org.apache.thrift.meta_data.FieldValueMetaData;
import org.apache.thrift.meta_data.ListMetaData;
import org.apache.thrift.protocol.*;
import org.apache.thrift.transport.TMemoryInputTransport;
import org.apache.thrift.transport.TNonblockingTransport;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

public class HelloWorld {

    public interface Iface {

        public String ping() throws TException;

        public String say(String msg) throws TException;

        public List<String> splitSentence(String sentence) throws TException;

    }

    public interface AsyncIface {

        public void ping(AsyncMethodCallback<AsyncClient.ping_call> resultHandler) throws TException;

        public void say(String msg, AsyncMethodCallback<AsyncClient.say_call> resultHandler) throws TException;

        public void splitSentence(String sentence, AsyncMethodCallback<AsyncClient.splitSentence_call> resultHandler) throws TException;

    }

    public static class Client implements TServiceClient, Iface {
        public static class Factory implements TServiceClientFactory<Client> {
            public Factory() {
            }

            public Client getClient(TProtocol prot) {
                return new Client(prot);
            }

            public Client getClient(TProtocol iprot, TProtocol oprot) {
                return new Client(iprot, oprot);
            }
        }

        public Client(TProtocol prot) {
            this(prot, prot);
        }

        public Client(TProtocol iprot, TProtocol oprot) {
            iprot_ = iprot;
            oprot_ = oprot;
        }

        protected TProtocol iprot_;
        protected TProtocol oprot_;

        protected int seqid_;

        public TProtocol getInputProtocol() {
            return this.iprot_;
        }

        public TProtocol getOutputProtocol() {
            return this.oprot_;
        }

        public String ping() throws TException {
            send_ping();
            return recv_ping();
        }

        public void send_ping() throws TException {
            oprot_.writeMessageBegin(new TMessage("ping", TMessageType.CALL, ++seqid_));
            ping_args args = new ping_args();
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public String recv_ping() throws TException {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION) {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            if (msg.seqid != seqid_) {
                throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "ping failed: out of sequence response");
            }
            ping_result result = new ping_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.isSetSuccess()) {
                return result.success;
            }
            throw new TApplicationException(TApplicationException.MISSING_RESULT, "ping failed: unknown result");
        }

        public String say(String msg) throws TException {
            send_say(msg);
            return recv_say();
        }

        public void send_say(String msg) throws TException {
            oprot_.writeMessageBegin(new TMessage("say", TMessageType.CALL, ++seqid_));
            say_args args = new say_args();
            args.setMsg(msg);
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public String recv_say() throws TException {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION) {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            if (msg.seqid != seqid_) {
                throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "say failed: out of sequence response");
            }
            say_result result = new say_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.isSetSuccess()) {
                return result.success;
            }
            throw new TApplicationException(TApplicationException.MISSING_RESULT, "say failed: unknown result");
        }

        public List<String> splitSentence(String sentence) throws TException {
            send_splitSentence(sentence);
            return recv_splitSentence();
        }

        public void send_splitSentence(String sentence) throws TException {
            oprot_.writeMessageBegin(new TMessage("splitSentence", TMessageType.CALL, ++seqid_));
            splitSentence_args args = new splitSentence_args();
            args.setSentence(sentence);
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public List<String> recv_splitSentence() throws TException {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION) {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            if (msg.seqid != seqid_) {
                throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "splitSentence failed: out of sequence response");
            }
            splitSentence_result result = new splitSentence_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.isSetSuccess()) {
                return result.success;
            }
            throw new TApplicationException(TApplicationException.MISSING_RESULT, "splitSentence failed: unknown result");
        }

    }

    public static class AsyncClient extends TAsyncClient implements AsyncIface {
        public static class Factory implements TAsyncClientFactory<AsyncClient> {
            private TAsyncClientManager clientManager;
            private TProtocolFactory protocolFactory;

            public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
                this.clientManager = clientManager;
                this.protocolFactory = protocolFactory;
            }

            public AsyncClient getAsyncClient(TNonblockingTransport transport) {
                return new AsyncClient(protocolFactory, clientManager, transport);
            }
        }

        public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
            super(protocolFactory, clientManager, transport);
        }

        public void ping(AsyncMethodCallback<ping_call> resultHandler) throws TException {
            checkReady();
            ping_call method_call = new ping_call(resultHandler, this, protocolFactory, transport);
            manager.call(method_call);
        }

        public static class ping_call extends TAsyncMethodCall {
            public ping_call(AsyncMethodCallback<ping_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
                super(client, protocolFactory, transport, resultHandler, false);
            }

            public void write_args(TProtocol prot) throws TException {
                prot.writeMessageBegin(new TMessage("ping", TMessageType.CALL, 0));
                ping_args args = new ping_args();
                args.write(prot);
                prot.writeMessageEnd();
            }

            public String getResult() throws TException {
                if (getState() != State.RESPONSE_READ) {
                    throw new IllegalStateException("Method call not finished!");
                }
                TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
                TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
                return (new Client(prot)).recv_ping();
            }
        }

        public void say(String msg, AsyncMethodCallback<say_call> resultHandler) throws TException {
            checkReady();
            say_call method_call = new say_call(msg, resultHandler, this, protocolFactory, transport);
            manager.call(method_call);
        }

        public static class say_call extends TAsyncMethodCall {
            private String msg;

            public say_call(String msg, AsyncMethodCallback<say_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
                super(client, protocolFactory, transport, resultHandler, false);
                this.msg = msg;
            }

            public void write_args(TProtocol prot) throws TException {
                prot.writeMessageBegin(new TMessage("say", TMessageType.CALL, 0));
                say_args args = new say_args();
                args.setMsg(msg);
                args.write(prot);
                prot.writeMessageEnd();
            }

            public String getResult() throws TException {
                if (getState() != State.RESPONSE_READ) {
                    throw new IllegalStateException("Method call not finished!");
                }
                TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
                TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
                return (new Client(prot)).recv_say();
            }
        }

        public void splitSentence(String sentence, AsyncMethodCallback<splitSentence_call> resultHandler) throws TException {
            checkReady();
            splitSentence_call method_call = new splitSentence_call(sentence, resultHandler, this, protocolFactory, transport);
            manager.call(method_call);
        }

        public static class splitSentence_call extends TAsyncMethodCall {
            private String sentence;

            public splitSentence_call(String sentence, AsyncMethodCallback<splitSentence_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
                super(client, protocolFactory, transport, resultHandler, false);
                this.sentence = sentence;
            }

            public void write_args(TProtocol prot) throws TException {
                prot.writeMessageBegin(new TMessage("splitSentence", TMessageType.CALL, 0));
                splitSentence_args args = new splitSentence_args();
                args.setSentence(sentence);
                args.write(prot);
                prot.writeMessageEnd();
            }

            public List<String> getResult() throws TException {
                if (getState() != State.RESPONSE_READ) {
                    throw new IllegalStateException("Method call not finished!");
                }
                TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
                TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
                return (new Client(prot)).recv_splitSentence();
            }
        }

    }

    public static class Processor implements TProcessor {
        private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());

        public Processor(Iface iface) {
            iface_ = iface;
            processMap_.put("ping", new ping());
            processMap_.put("say", new say());
            processMap_.put("splitSentence", new splitSentence());
        }

        protected static interface ProcessFunction {
            public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
        }

        private Iface iface_;
        protected final HashMap<String, ProcessFunction> processMap_ = new HashMap<String, ProcessFunction>();

        public boolean process(TProtocol iprot, TProtocol oprot) throws TException {
            TMessage msg = iprot.readMessageBegin();
            ProcessFunction fn = processMap_.get(msg.name);
            if (fn == null) {
                TProtocolUtil.skip(iprot, TType.STRUCT);
                iprot.readMessageEnd();
                TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '" + msg.name + "'");
                oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
                x.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
                return true;
            }
            fn.process(msg.seqid, iprot, oprot);
            return true;
        }

        private class ping implements ProcessFunction {
            public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
                ping_args args = new ping_args();
                try {
                    args.read(iprot);
                } catch (TProtocolException e) {
                    iprot.readMessageEnd();
                    TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
                    oprot.writeMessageBegin(new TMessage("ping", TMessageType.EXCEPTION, seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                iprot.readMessageEnd();
                ping_result result = new ping_result();
                result.success = iface_.ping();
                oprot.writeMessageBegin(new TMessage("ping", TMessageType.REPLY, seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class say implements ProcessFunction {
            public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
                say_args args = new say_args();
                try {
                    args.read(iprot);
                } catch (TProtocolException e) {
                    iprot.readMessageEnd();
                    TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
                    oprot.writeMessageBegin(new TMessage("say", TMessageType.EXCEPTION, seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                iprot.readMessageEnd();
                say_result result = new say_result();
                result.success = iface_.say(args.msg);
                oprot.writeMessageBegin(new TMessage("say", TMessageType.REPLY, seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class splitSentence implements ProcessFunction {
            public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException {
                splitSentence_args args = new splitSentence_args();
                try {
                    args.read(iprot);
                } catch (TProtocolException e) {
                    iprot.readMessageEnd();
                    TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
                    oprot.writeMessageBegin(new TMessage("splitSentence", TMessageType.EXCEPTION, seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                iprot.readMessageEnd();
                splitSentence_result result = new splitSentence_result();
                result.success = iface_.splitSentence(args.sentence);
                oprot.writeMessageBegin(new TMessage("splitSentence", TMessageType.REPLY, seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

    }

    public static class ping_args implements TBase<ping_args, ping_args._Fields>, java.io.Serializable, Cloneable {
        private static final TStruct STRUCT_DESC = new TStruct("ping_args");


        /**
         * The set of fields this struct contains, along with convenience methods for finding and manipulating them.
         */
        public enum _Fields implements TFieldIdEnum {
            ;

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static {
                for (_Fields field : EnumSet.allOf(_Fields.class)) {
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(int fieldId) {
                switch (fieldId) {
                    default:
                        return null;
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception
             * if it is not found.
             */
            public static _Fields findByThriftIdOrThrow(int fieldId) {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(String name) {
                return byName.get(name);
            }

            private final short _thriftId;
            private final String _fieldName;

            _Fields(short thriftId, String fieldName) {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            public short getThriftFieldId() {
                return _thriftId;
            }

            public String getFieldName() {
                return _fieldName;
            }
        }

        public static final Map<_Fields, FieldMetaData> metaDataMap;

        static {
            Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
            metaDataMap = Collections.unmodifiableMap(tmpMap);
            FieldMetaData.addStructMetaDataMap(ping_args.class, metaDataMap);
        }

        public ping_args() {
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public ping_args(ping_args other) {
        }

        public ping_args deepCopy() {
            return new ping_args(this);
        }

        @Override
        public void clear() {
        }

        public void setFieldValue(_Fields field, Object value) {
            switch (field) {
            }
        }

        public Object getFieldValue(_Fields field) {
            switch (field) {
            }
            throw new IllegalStateException();
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
         */
        public boolean isSet(_Fields field) {
            if (field == null) {
                throw new IllegalArgumentException();
            }

            switch (field) {
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean equals(Object that) {
            if (that == null)
                return false;
            if (that instanceof ping_args)
                return this.equals((ping_args) that);
            return false;
        }

        public boolean equals(ping_args that) {
            if (that == null)
                return false;

            return true;
        }

        @Override
        public int hashCode() {
            return 0;
        }

        public int compareTo(ping_args other) {
            if (!getClass().equals(other.getClass())) {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            ping_args typedOther = (ping_args) other;

            return 0;
        }

        public _Fields fieldForId(int fieldId) {
            return _Fields.findByThriftId(fieldId);
        }

        public void read(TProtocol iprot) throws TException {
            TField field;
            iprot.readStructBegin();
            while (true) {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP) {
                    break;
                }
                switch (field.id) {
                    default:
                        TProtocolUtil.skip(iprot, field.type);
                }
                iprot.readFieldEnd();
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate method
            validate();
        }

        public void write(TProtocol oprot) throws TException {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder("ping_args(");
            boolean first = true;

            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException {
            // check for required fields
        }

    }

    public static class ping_result implements TBase<ping_result, ping_result._Fields>, java.io.Serializable, Cloneable {
        private static final TStruct STRUCT_DESC = new TStruct("ping_result");

        private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short) 0);

        public String success;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and manipulating them.
         */
        public enum _Fields implements TFieldIdEnum {
            SUCCESS((short) 0, "success");

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static {
                for (_Fields field : EnumSet.allOf(_Fields.class)) {
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(int fieldId) {
                switch (fieldId) {
                    case 0: // SUCCESS
                        return SUCCESS;
                    default:
                        return null;
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception
             * if it is not found.
             */
            public static _Fields findByThriftIdOrThrow(int fieldId) {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(String name) {
                return byName.get(name);
            }

            private final short _thriftId;
            private final String _fieldName;

            _Fields(short thriftId, String fieldName) {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            public short getThriftFieldId() {
                return _thriftId;
            }

            public String getFieldName() {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap;

        static {
            Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
            tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
                    new FieldValueMetaData(TType.STRING)));
            metaDataMap = Collections.unmodifiableMap(tmpMap);
            FieldMetaData.addStructMetaDataMap(ping_result.class, metaDataMap);
        }

        public ping_result() {
        }

        public ping_result(
                String success) {
            this();
            this.success = success;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public ping_result(ping_result other) {
            if (other.isSetSuccess()) {
                this.success = other.success;
            }
        }

        public ping_result deepCopy() {
            return new ping_result(this);
        }

        @Override
        public void clear() {
            this.success = null;
        }

        public String getSuccess() {
            return this.success;
        }

        public ping_result setSuccess(String success) {
            this.success = success;
            return this;
        }

        public void unsetSuccess() {
            this.success = null;
        }

        /**
         * Returns true if field success is set (has been asigned a value) and false otherwise
         */
        public boolean isSetSuccess() {
            return this.success != null;
        }

        public void setSuccessIsSet(boolean value) {
            if (!value) {
                this.success = null;
            }
        }

        public void setFieldValue(_Fields field, Object value) {
            switch (field) {
                case SUCCESS:
                    if (value == null) {
                        unsetSuccess();
                    } else {
                        setSuccess((String) value);
                    }
                    break;

            }
        }

        public Object getFieldValue(_Fields field) {
            switch (field) {
                case SUCCESS:
                    return getSuccess();

            }
            throw new IllegalStateException();
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
         */
        public boolean isSet(_Fields field) {
            if (field == null) {
                throw new IllegalArgumentException();
            }

            switch (field) {
                case SUCCESS:
                    return isSetSuccess();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean equals(Object that) {
            if (that == null)
                return false;
            if (that instanceof ping_result)
                return this.equals((ping_result) that);
            return false;
        }

        public boolean equals(ping_result that) {
            if (that == null)
                return false;

            boolean this_present_success = true && this.isSetSuccess();
            boolean that_present_success = true && that.isSetSuccess();
            if (this_present_success || that_present_success) {
                if (!(this_present_success && that_present_success))
                    return false;
                if (!this.success.equals(that.success))
                    return false;
            }

            return true;
        }

        @Override
        public int hashCode() {
            return 0;
        }

        public int compareTo(ping_result other) {
            if (!getClass().equals(other.getClass())) {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            ping_result typedOther = (ping_result) other;

            lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
            if (lastComparison != 0) {
                return lastComparison;
            }
            if (isSetSuccess()) {
                lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
                if (lastComparison != 0) {
                    return lastComparison;
                }
            }
            return 0;
        }

        public _Fields fieldForId(int fieldId) {
            return _Fields.findByThriftId(fieldId);
        }

        public void read(TProtocol iprot) throws TException {
            TField field;
            iprot.readStructBegin();
            while (true) {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP) {
                    break;
                }
                switch (field.id) {
                    case 0: // SUCCESS
                        if (field.type == TType.STRING) {
                            this.success = iprot.readString();
                        } else {
                            TProtocolUtil.skip(iprot, field.type);
                        }
                        break;
                    default:
                        TProtocolUtil.skip(iprot, field.type);
                }
                iprot.readFieldEnd();
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate method
            validate();
        }

        public void write(TProtocol oprot) throws TException {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetSuccess()) {
                oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
                oprot.writeString(this.success);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder("ping_result(");
            boolean first = true;

            sb.append("success:");
            if (this.success == null) {
                sb.append("null");
            } else {
                sb.append(this.success);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException {
            // check for required fields
        }

    }

    public static class say_args implements TBase<say_args, say_args._Fields>, java.io.Serializable, Cloneable {
        private static final TStruct STRUCT_DESC = new TStruct("say_args");

        private static final TField MSG_FIELD_DESC = new TField("msg", TType.STRING, (short) 1);

        public String msg;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and manipulating them.
         */
        public enum _Fields implements TFieldIdEnum {
            MSG((short) 1, "msg");

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static {
                for (_Fields field : EnumSet.allOf(_Fields.class)) {
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(int fieldId) {
                switch (fieldId) {
                    case 1: // MSG
                        return MSG;
                    default:
                        return null;
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception
             * if it is not found.
             */
            public static _Fields findByThriftIdOrThrow(int fieldId) {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(String name) {
                return byName.get(name);
            }

            private final short _thriftId;
            private final String _fieldName;

            _Fields(short thriftId, String fieldName) {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            public short getThriftFieldId() {
                return _thriftId;
            }

            public String getFieldName() {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap;

        static {
            Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
            tmpMap.put(_Fields.MSG, new FieldMetaData("msg", TFieldRequirementType.DEFAULT,
                    new FieldValueMetaData(TType.STRING)));
            metaDataMap = Collections.unmodifiableMap(tmpMap);
            FieldMetaData.addStructMetaDataMap(say_args.class, metaDataMap);
        }

        public say_args() {
        }

        public say_args(
                String msg) {
            this();
            this.msg = msg;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public say_args(say_args other) {
            if (other.isSetMsg()) {
                this.msg = other.msg;
            }
        }

        public say_args deepCopy() {
            return new say_args(this);
        }

        @Override
        public void clear() {
            this.msg = null;
        }

        public String getMsg() {
            return this.msg;
        }

        public say_args setMsg(String msg) {
            this.msg = msg;
            return this;
        }

        public void unsetMsg() {
            this.msg = null;
        }

        /**
         * Returns true if field msg is set (has been asigned a value) and false otherwise
         */
        public boolean isSetMsg() {
            return this.msg != null;
        }

        public void setMsgIsSet(boolean value) {
            if (!value) {
                this.msg = null;
            }
        }

        public void setFieldValue(_Fields field, Object value) {
            switch (field) {
                case MSG:
                    if (value == null) {
                        unsetMsg();
                    } else {
                        setMsg((String) value);
                    }
                    break;

            }
        }

        public Object getFieldValue(_Fields field) {
            switch (field) {
                case MSG:
                    return getMsg();

            }
            throw new IllegalStateException();
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
         */
        public boolean isSet(_Fields field) {
            if (field == null) {
                throw new IllegalArgumentException();
            }

            switch (field) {
                case MSG:
                    return isSetMsg();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean equals(Object that) {
            if (that == null)
                return false;
            if (that instanceof say_args)
                return this.equals((say_args) that);
            return false;
        }

        public boolean equals(say_args that) {
            if (that == null)
                return false;

            boolean this_present_msg = true && this.isSetMsg();
            boolean that_present_msg = true && that.isSetMsg();
            if (this_present_msg || that_present_msg) {
                if (!(this_present_msg && that_present_msg))
                    return false;
                if (!this.msg.equals(that.msg))
                    return false;
            }

            return true;
        }

        @Override
        public int hashCode() {
            return 0;
        }

        public int compareTo(say_args other) {
            if (!getClass().equals(other.getClass())) {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            say_args typedOther = (say_args) other;

            lastComparison = Boolean.valueOf(isSetMsg()).compareTo(typedOther.isSetMsg());
            if (lastComparison != 0) {
                return lastComparison;
            }
            if (isSetMsg()) {
                lastComparison = TBaseHelper.compareTo(this.msg, typedOther.msg);
                if (lastComparison != 0) {
                    return lastComparison;
                }
            }
            return 0;
        }

        public _Fields fieldForId(int fieldId) {
            return _Fields.findByThriftId(fieldId);
        }

        public void read(TProtocol iprot) throws TException {
            TField field;
            iprot.readStructBegin();
            while (true) {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP) {
                    break;
                }
                switch (field.id) {
                    case 1: // MSG
                        if (field.type == TType.STRING) {
                            this.msg = iprot.readString();
                        } else {
                            TProtocolUtil.skip(iprot, field.type);
                        }
                        break;
                    default:
                        TProtocolUtil.skip(iprot, field.type);
                }
                iprot.readFieldEnd();
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate method
            validate();
        }

        public void write(TProtocol oprot) throws TException {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            if (this.msg != null) {
                oprot.writeFieldBegin(MSG_FIELD_DESC);
                oprot.writeString(this.msg);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder("say_args(");
            boolean first = true;

            sb.append("msg:");
            if (this.msg == null) {
                sb.append("null");
            } else {
                sb.append(this.msg);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException {
            // check for required fields
        }

    }

    public static class say_result implements TBase<say_result, say_result._Fields>, java.io.Serializable, Cloneable {
        private static final TStruct STRUCT_DESC = new TStruct("say_result");

        private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short) 0);

        public String success;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and manipulating them.
         */
        public enum _Fields implements TFieldIdEnum {
            SUCCESS((short) 0, "success");

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static {
                for (_Fields field : EnumSet.allOf(_Fields.class)) {
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(int fieldId) {
                switch (fieldId) {
                    case 0: // SUCCESS
                        return SUCCESS;
                    default:
                        return null;
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception
             * if it is not found.
             */
            public static _Fields findByThriftIdOrThrow(int fieldId) {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(String name) {
                return byName.get(name);
            }

            private final short _thriftId;
            private final String _fieldName;

            _Fields(short thriftId, String fieldName) {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            public short getThriftFieldId() {
                return _thriftId;
            }

            public String getFieldName() {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap;

        static {
            Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
            tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
                    new FieldValueMetaData(TType.STRING)));
            metaDataMap = Collections.unmodifiableMap(tmpMap);
            FieldMetaData.addStructMetaDataMap(say_result.class, metaDataMap);
        }

        public say_result() {
        }

        public say_result(
                String success) {
            this();
            this.success = success;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public say_result(say_result other) {
            if (other.isSetSuccess()) {
                this.success = other.success;
            }
        }

        public say_result deepCopy() {
            return new say_result(this);
        }

        @Override
        public void clear() {
            this.success = null;
        }

        public String getSuccess() {
            return this.success;
        }

        public say_result setSuccess(String success) {
            this.success = success;
            return this;
        }

        public void unsetSuccess() {
            this.success = null;
        }

        /**
         * Returns true if field success is set (has been asigned a value) and false otherwise
         */
        public boolean isSetSuccess() {
            return this.success != null;
        }

        public void setSuccessIsSet(boolean value) {
            if (!value) {
                this.success = null;
            }
        }

        public void setFieldValue(_Fields field, Object value) {
            switch (field) {
                case SUCCESS:
                    if (value == null) {
                        unsetSuccess();
                    } else {
                        setSuccess((String) value);
                    }
                    break;

            }
        }

        public Object getFieldValue(_Fields field) {
            switch (field) {
                case SUCCESS:
                    return getSuccess();

            }
            throw new IllegalStateException();
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
         */
        public boolean isSet(_Fields field) {
            if (field == null) {
                throw new IllegalArgumentException();
            }

            switch (field) {
                case SUCCESS:
                    return isSetSuccess();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean equals(Object that) {
            if (that == null)
                return false;
            if (that instanceof say_result)
                return this.equals((say_result) that);
            return false;
        }

        public boolean equals(say_result that) {
            if (that == null)
                return false;

            boolean this_present_success = true && this.isSetSuccess();
            boolean that_present_success = true && that.isSetSuccess();
            if (this_present_success || that_present_success) {
                if (!(this_present_success && that_present_success))
                    return false;
                if (!this.success.equals(that.success))
                    return false;
            }

            return true;
        }

        @Override
        public int hashCode() {
            return 0;
        }

        public int compareTo(say_result other) {
            if (!getClass().equals(other.getClass())) {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            say_result typedOther = (say_result) other;

            lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
            if (lastComparison != 0) {
                return lastComparison;
            }
            if (isSetSuccess()) {
                lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
                if (lastComparison != 0) {
                    return lastComparison;
                }
            }
            return 0;
        }

        public _Fields fieldForId(int fieldId) {
            return _Fields.findByThriftId(fieldId);
        }

        public void read(TProtocol iprot) throws TException {
            TField field;
            iprot.readStructBegin();
            while (true) {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP) {
                    break;
                }
                switch (field.id) {
                    case 0: // SUCCESS
                        if (field.type == TType.STRING) {
                            this.success = iprot.readString();
                        } else {
                            TProtocolUtil.skip(iprot, field.type);
                        }
                        break;
                    default:
                        TProtocolUtil.skip(iprot, field.type);
                }
                iprot.readFieldEnd();
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate method
            validate();
        }

        public void write(TProtocol oprot) throws TException {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetSuccess()) {
                oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
                oprot.writeString(this.success);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder("say_result(");
            boolean first = true;

            sb.append("success:");
            if (this.success == null) {
                sb.append("null");
            } else {
                sb.append(this.success);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException {
            // check for required fields
        }

    }

    public static class splitSentence_args implements TBase<splitSentence_args, splitSentence_args._Fields>, java.io.Serializable, Cloneable {
        private static final TStruct STRUCT_DESC = new TStruct("splitSentence_args");

        private static final TField SENTENCE_FIELD_DESC = new TField("sentence", TType.STRING, (short) 1);

        public String sentence;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and manipulating them.
         */
        public enum _Fields implements TFieldIdEnum {
            SENTENCE((short) 1, "sentence");

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static {
                for (_Fields field : EnumSet.allOf(_Fields.class)) {
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(int fieldId) {
                switch (fieldId) {
                    case 1: // SENTENCE
                        return SENTENCE;
                    default:
                        return null;
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception
             * if it is not found.
             */
            public static _Fields findByThriftIdOrThrow(int fieldId) {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(String name) {
                return byName.get(name);
            }

            private final short _thriftId;
            private final String _fieldName;

            _Fields(short thriftId, String fieldName) {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            public short getThriftFieldId() {
                return _thriftId;
            }

            public String getFieldName() {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap;

        static {
            Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
            tmpMap.put(_Fields.SENTENCE, new FieldMetaData("sentence", TFieldRequirementType.DEFAULT,
                    new FieldValueMetaData(TType.STRING)));
            metaDataMap = Collections.unmodifiableMap(tmpMap);
            FieldMetaData.addStructMetaDataMap(splitSentence_args.class, metaDataMap);
        }

        public splitSentence_args() {
        }

        public splitSentence_args(
                String sentence) {
            this();
            this.sentence = sentence;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public splitSentence_args(splitSentence_args other) {
            if (other.isSetSentence()) {
                this.sentence = other.sentence;
            }
        }

        public splitSentence_args deepCopy() {
            return new splitSentence_args(this);
        }

        @Override
        public void clear() {
            this.sentence = null;
        }

        public String getSentence() {
            return this.sentence;
        }

        public splitSentence_args setSentence(String sentence) {
            this.sentence = sentence;
            return this;
        }

        public void unsetSentence() {
            this.sentence = null;
        }

        /**
         * Returns true if field sentence is set (has been asigned a value) and false otherwise
         */
        public boolean isSetSentence() {
            return this.sentence != null;
        }

        public void setSentenceIsSet(boolean value) {
            if (!value) {
                this.sentence = null;
            }
        }

        public void setFieldValue(_Fields field, Object value) {
            switch (field) {
                case SENTENCE:
                    if (value == null) {
                        unsetSentence();
                    } else {
                        setSentence((String) value);
                    }
                    break;

            }
        }

        public Object getFieldValue(_Fields field) {
            switch (field) {
                case SENTENCE:
                    return getSentence();

            }
            throw new IllegalStateException();
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
         */
        public boolean isSet(_Fields field) {
            if (field == null) {
                throw new IllegalArgumentException();
            }

            switch (field) {
                case SENTENCE:
                    return isSetSentence();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean equals(Object that) {
            if (that == null)
                return false;
            if (that instanceof splitSentence_args)
                return this.equals((splitSentence_args) that);
            return false;
        }

        public boolean equals(splitSentence_args that) {
            if (that == null)
                return false;

            boolean this_present_sentence = true && this.isSetSentence();
            boolean that_present_sentence = true && that.isSetSentence();
            if (this_present_sentence || that_present_sentence) {
                if (!(this_present_sentence && that_present_sentence))
                    return false;
                if (!this.sentence.equals(that.sentence))
                    return false;
            }

            return true;
        }

        @Override
        public int hashCode() {
            return 0;
        }

        public int compareTo(splitSentence_args other) {
            if (!getClass().equals(other.getClass())) {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            splitSentence_args typedOther = (splitSentence_args) other;

            lastComparison = Boolean.valueOf(isSetSentence()).compareTo(typedOther.isSetSentence());
            if (lastComparison != 0) {
                return lastComparison;
            }
            if (isSetSentence()) {
                lastComparison = TBaseHelper.compareTo(this.sentence, typedOther.sentence);
                if (lastComparison != 0) {
                    return lastComparison;
                }
            }
            return 0;
        }

        public _Fields fieldForId(int fieldId) {
            return _Fields.findByThriftId(fieldId);
        }

        public void read(TProtocol iprot) throws TException {
            TField field;
            iprot.readStructBegin();
            while (true) {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP) {
                    break;
                }
                switch (field.id) {
                    case 1: // SENTENCE
                        if (field.type == TType.STRING) {
                            this.sentence = iprot.readString();
                        } else {
                            TProtocolUtil.skip(iprot, field.type);
                        }
                        break;
                    default:
                        TProtocolUtil.skip(iprot, field.type);
                }
                iprot.readFieldEnd();
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate method
            validate();
        }

        public void write(TProtocol oprot) throws TException {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            if (this.sentence != null) {
                oprot.writeFieldBegin(SENTENCE_FIELD_DESC);
                oprot.writeString(this.sentence);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder("splitSentence_args(");
            boolean first = true;

            sb.append("sentence:");
            if (this.sentence == null) {
                sb.append("null");
            } else {
                sb.append(this.sentence);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException {
            // check for required fields
        }

    }

    public static class splitSentence_result implements TBase<splitSentence_result, splitSentence_result._Fields>, java.io.Serializable, Cloneable {
        private static final TStruct STRUCT_DESC = new TStruct("splitSentence_result");

        private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short) 0);

        public List<String> success;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and manipulating them.
         */
        public enum _Fields implements TFieldIdEnum {
            SUCCESS((short) 0, "success");

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static {
                for (_Fields field : EnumSet.allOf(_Fields.class)) {
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(int fieldId) {
                switch (fieldId) {
                    case 0: // SUCCESS
                        return SUCCESS;
                    default:
                        return null;
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception
             * if it is not found.
             */
            public static _Fields findByThriftIdOrThrow(int fieldId) {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(String name) {
                return byName.get(name);
            }

            private final short _thriftId;
            private final String _fieldName;

            _Fields(short thriftId, String fieldName) {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            public short getThriftFieldId() {
                return _thriftId;
            }

            public String getFieldName() {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap;

        static {
            Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
            tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT,
                    new ListMetaData(TType.LIST,
                            new FieldValueMetaData(TType.STRING))));
            metaDataMap = Collections.unmodifiableMap(tmpMap);
            FieldMetaData.addStructMetaDataMap(splitSentence_result.class, metaDataMap);
        }

        public splitSentence_result() {
        }

        public splitSentence_result(
                List<String> success) {
            this();
            this.success = success;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public splitSentence_result(splitSentence_result other) {
            if (other.isSetSuccess()) {
                List<String> __this__success = new ArrayList<String>();
                for (String other_element : other.success) {
                    __this__success.add(other_element);
                }
                this.success = __this__success;
            }
        }

        public splitSentence_result deepCopy() {
            return new splitSentence_result(this);
        }

        @Override
        public void clear() {
            this.success = null;
        }

        public int getSuccessSize() {
            return (this.success == null) ? 0 : this.success.size();
        }

        public java.util.Iterator<String> getSuccessIterator() {
            return (this.success == null) ? null : this.success.iterator();
        }

        public void addToSuccess(String elem) {
            if (this.success == null) {
                this.success = new ArrayList<String>();
            }
            this.success.add(elem);
        }

        public List<String> getSuccess() {
            return this.success;
        }

        public splitSentence_result setSuccess(List<String> success) {
            this.success = success;
            return this;
        }

        public void unsetSuccess() {
            this.success = null;
        }

        /**
         * Returns true if field success is set (has been asigned a value) and false otherwise
         */
        public boolean isSetSuccess() {
            return this.success != null;
        }

        public void setSuccessIsSet(boolean value) {
            if (!value) {
                this.success = null;
            }
        }

        public void setFieldValue(_Fields field, Object value) {
            switch (field) {
                case SUCCESS:
                    if (value == null) {
                        unsetSuccess();
                    } else {
                        setSuccess((List<String>) value);
                    }
                    break;

            }
        }

        public Object getFieldValue(_Fields field) {
            switch (field) {
                case SUCCESS:
                    return getSuccess();

            }
            throw new IllegalStateException();
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
         */
        public boolean isSet(_Fields field) {
            if (field == null) {
                throw new IllegalArgumentException();
            }

            switch (field) {
                case SUCCESS:
                    return isSetSuccess();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean equals(Object that) {
            if (that == null)
                return false;
            if (that instanceof splitSentence_result)
                return this.equals((splitSentence_result) that);
            return false;
        }

        public boolean equals(splitSentence_result that) {
            if (that == null)
                return false;

            boolean this_present_success = true && this.isSetSuccess();
            boolean that_present_success = true && that.isSetSuccess();
            if (this_present_success || that_present_success) {
                if (!(this_present_success && that_present_success))
                    return false;
                if (!this.success.equals(that.success))
                    return false;
            }

            return true;
        }

        @Override
        public int hashCode() {
            return 0;
        }

        public int compareTo(splitSentence_result other) {
            if (!getClass().equals(other.getClass())) {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            splitSentence_result typedOther = (splitSentence_result) other;

            lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
            if (lastComparison != 0) {
                return lastComparison;
            }
            if (isSetSuccess()) {
                lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
                if (lastComparison != 0) {
                    return lastComparison;
                }
            }
            return 0;
        }

        public _Fields fieldForId(int fieldId) {
            return _Fields.findByThriftId(fieldId);
        }

        public void read(TProtocol iprot) throws TException {
            TField field;
            iprot.readStructBegin();
            while (true) {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP) {
                    break;
                }
                switch (field.id) {
                    case 0: // SUCCESS
                        if (field.type == TType.LIST) {
                            {
                                TList _list0 = iprot.readListBegin();
                                this.success = new ArrayList<String>(_list0.size);
                                for (int _i1 = 0; _i1 < _list0.size; ++_i1) {
                                    String _elem2;
                                    _elem2 = iprot.readString();
                                    this.success.add(_elem2);
                                }
                                iprot.readListEnd();
                            }
                        } else {
                            TProtocolUtil.skip(iprot, field.type);
                        }
                        break;
                    default:
                        TProtocolUtil.skip(iprot, field.type);
                }
                iprot.readFieldEnd();
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate method
            validate();
        }

        public void write(TProtocol oprot) throws TException {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetSuccess()) {
                oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
                {
                    oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
                    for (String _iter3 : this.success) {
                        oprot.writeString(_iter3);
                    }
                    oprot.writeListEnd();
                }
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder("splitSentence_result(");
            boolean first = true;

            sb.append("success:");
            if (this.success == null) {
                sb.append("null");
            } else {
                sb.append(this.success);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException {
            // check for required fields
        }

    }

}
